"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processDynamicStyles = void 0;
const Styles_1 = require("../common/Styles");
const processDynamicStyleProp = (style, options, output) => {
    const resolvedOutput = output || {
        classes: [],
        result: [],
        requiresPostProcessing: undefined,
    };
    if (!style) {
        return resolvedOutput;
    }
    if (typeof style === "string") {
        resolvedOutput.classes.push(style);
        resolvedOutput.result.push(style);
        return resolvedOutput;
    }
    if (Array.isArray(style)) {
        style.map((subStyle) => processDynamicStyleProp(subStyle, options, resolvedOutput));
        return resolvedOutput;
    }
    if ((0, Styles_1.isDynamicStyle)(style)) {
        resolvedOutput.classes.push(style.__name);
        resolvedOutput.result.push(style);
        if (style.__dynamic.mediaQueries) {
            //console.log(style.__mediaQueries);
        }
        if (style.__dynamic.dynamicProperties) {
            for (const dynamicProperty of style.__dynamic.dynamicProperties) {
                const dynamicValue = style[dynamicProperty];
                style[dynamicProperty] = processDynamicProperty(dynamicValue, options);
            }
        }
        if (style.__dynamic.when) {
            if (!resolvedOutput.requiresPostProcessing) {
                resolvedOutput.requiresPostProcessing = [];
            }
            resolvedOutput.requiresPostProcessing.push(resolvedOutput.result.length - 1);
        }
        if (style.__dynamic.vars) {
            resolvedOutput.result.push(Object.keys(style.__dynamic.vars).reduce((dynamic, key) => {
                const varKey = style.__dynamic.vars[key];
                dynamic[key] = options.vars[varKey];
                return dynamic;
            }, {}));
        }
    }
    else {
        if ((0, Styles_1.isNamedStyle)(style)) {
            resolvedOutput.classes.push(style.__name);
        }
        resolvedOutput.result.push(style);
    }
    return resolvedOutput;
};
const postProcessDynamicStyles = (output, options) => {
    if (!output.requiresPostProcessing || output.requiresPostProcessing.length === 0) {
        return;
    }
    const dynamicStylesBySource = {};
    for (const index of output.requiresPostProcessing) {
        const style = output.result[index];
        if ((0, Styles_1.isDynamicStyle)(style)) {
            if (style.__dynamic.when) {
                for (const whenCondition of style.__dynamic.when) {
                    let completedIndex = -1;
                    const meetsCondition = whenCondition.classes.every((className, index) => {
                        completedIndex = index;
                        return output.classes.includes(className);
                    });
                    if (meetsCondition) {
                        const dynamicStyles = dynamicStylesBySource[style.__source] || (dynamicStylesBySource[style.__source] = []);
                        (dynamicStyles[whenCondition.style.__precedence - 1] || (dynamicStyles[whenCondition.style.__precedence - 1] = [])).push(whenCondition.style);
                    }
                }
            }
        }
    }
    // we want to insert all the nested styles after all the styles from the source file they were from
    // this means that .btn.sm.primary is insert after all .btn.sm styles, and all .btn styles
    // but importantly less nested styles from other source files are not superseded
    for (const source in dynamicStylesBySource) {
        const dynamicStyles = dynamicStylesBySource[source];
        let lastOfSource = -1;
        for (let i = output.result.length; i >= 0; i--) {
            const style = output.result[i];
            if ((0, Styles_1.isNamedStyle)(style) && style.__source === Number(source)) {
                lastOfSource = i;
                break;
            }
        }
        output.result.splice(lastOfSource + 1, 0, ...dynamicStyles.flat(1));
        if (options.debug) {
            console.log(output.result, lastOfSource, dynamicStyles);
        }
    }
};
const processDynamicStyles = (style, options) => {
    const processingOutput = processDynamicStyleProp(style, options);
    postProcessDynamicStyles(processingOutput, options);
    return processingOutput;
};
exports.processDynamicStyles = processDynamicStyles;
const processDynamicProperty = (value, options) => {
    if (typeof value === "string") {
        if (value.endsWith("rem")) {
            const remValue = Number(value.replace("rem", ""));
            return remValue * (options.baseFontSize || 16);
        }
    }
    return value;
};
