"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateReactNativeStyles = void 0;
const CssParser_1 = require("./CssParser");
const CssWhat = __importStar(require("css-what"));
const index_1 = require("../../vendored/css-to-react-native/src/index");
const SHORTHAND_BORDER_PROPS = [
    "borderRadius",
    "borderWidth",
    "borderColor",
    "borderStyle",
];
let sourceCounter = 0;
const generateReactNativeStyles = (options) => {
    const { stylesheet, css } = (0, CssParser_1.parseCss)(options);
    const styles = {};
    const sourceId = sourceCounter++;
    const allClasses = new Set();
    for (const rule of stylesheet.rules) {
        if (rule.type === "rule") {
            const { selectors, declarations } = rule;
            if (selectors && declarations) {
                const styleObject = {};
                // 1. turn all "background: red" into {backgroundColor: "red"}
                for (const decl of declarations) {
                    if (decl.type === "declaration" && decl.property && decl.value) {
                        const property = (0, index_1.getPropertyName)(decl.property);
                        const processedStyle = (0, index_1.getStylesForProperty)(property, decl.value);
                        // transform "border-width" back into only "borderWidth" if only one value present
                        if (SHORTHAND_BORDER_PROPS.includes(property)) {
                            const values = Object.values(processedStyle);
                            if (values.every(v => values[0] === v)) {
                                styleObject[(0, index_1.getPropertyName)(property)] = values[0];
                            }
                        }
                        else {
                            Object.assign(styleObject, processedStyle);
                        }
                    }
                }
                // 2. grab any vars
                const dynamicProperties = new Set();
                const vars = {};
                for (const key of Object.keys(styleObject)) {
                    const value = styleObject[key];
                    if (value) {
                        if (typeof value === "object" && value.var) {
                            vars[key] = value.var;
                            delete styleObject[key];
                        }
                        else if (typeof value === "string" && value.endsWith("rem")) {
                            dynamicProperties.add(key);
                        }
                    }
                }
                // 3. parse selectors for this rule, could be more than one: ".sm, .small"
                for (const selector of selectors) {
                    const classes = [];
                    let selectorSupported = true;
                    const [parsedSelector] = CssWhat.parse(selector);
                    for (const selectorElement of parsedSelector) {
                        if (selectorElement.type === "attribute") {
                            if (selectorElement.name === "class") {
                                classes.push(selectorElement.value);
                                allClasses.add(selectorElement.value);
                            }
                            else {
                                selectorSupported = false;
                            }
                        }
                        else {
                            selectorSupported = false;
                        }
                    }
                    // at least one class present in selector
                    if (classes.length > 0 && selectorSupported) {
                        const name = classes.pop();
                        const selectorStyleObject = styles[name] || (styles[name] = {
                            __name: name,
                            __source: sourceId,
                        });
                        if (Object.keys(vars).length > 0) {
                            const dynamic = selectorStyleObject.__dynamic || (selectorStyleObject.__dynamic = {});
                            dynamic.vars = vars;
                        }
                        if (dynamicProperties.size > 0) {
                            const dynamic = selectorStyleObject.__dynamic || (selectorStyleObject.__dynamic = {});
                            dynamic.dynamicProperties = dynamicProperties;
                        }
                        // complex selector with multiple classes
                        if (classes.length > 0) {
                            const dynamic = selectorStyleObject.__dynamic || (selectorStyleObject.__dynamic = {});
                            const when = dynamic.when || (dynamic.when = []);
                            styleObject.__precedence = classes.length;
                            when.push({
                                classes: classes,
                                style: styleObject,
                            });
                        }
                        else {
                            Object.assign(selectorStyleObject, styleObject);
                        }
                    }
                }
            }
        }
    }
    // find any classes that are mentioned in selectors but were removed during SASS compile due to having no rules of their own
    Object.keys(styles).forEach(className => allClasses.delete(className));
    for (const missingClass of allClasses) {
        styles[missingClass] = { __name: missingClass };
    }
    return { styles, css, stylesheet };
};
exports.generateReactNativeStyles = generateReactNativeStyles;
