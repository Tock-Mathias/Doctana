"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseCss = void 0;
const css_1 = __importDefault(require("css"));
const sass_1 = __importDefault(require("sass"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
// Iterate through the include paths and extensions to find the file variant
const findVariant = (name, extensions, includePaths) => {
    for (let i = 0; i < includePaths.length; i++) {
        const includePath = includePaths[i];
        // try to find the file iterating through the extensions, in order.
        const foundExtention = extensions.find((extension) => {
            const fname = includePath + "/" + name + extension;
            const partialfname = includePath + "/_" + name + extension;
            return fs_1.default.existsSync(fname) || fs_1.default.existsSync(partialfname);
        });
        if (foundExtention) {
            return includePath + "/" + name + foundExtention;
        }
    }
    return false;
};
const INCLUDE_PATHS = [process.cwd(), path_1.default.resolve(process.cwd(), "node_modules")];
const resolveSassOptions = (options) => {
    const { filename, src, platform } = options;
    const exts = ["sass", "scss"].flatMap(ext => [
        // add the platform specific extension, first in the array to take precedence
        platform === "android" ? ".android" + ext : ".ios" + ext,
        ".native" + ext,
    ]);
    const data = filename ? fs_1.default.readFileSync(filename).toString() : src;
    return {
        includePaths: filename ? [path_1.default.dirname(filename), ...INCLUDE_PATHS] : INCLUDE_PATHS,
        indentedSyntax: filename === null || filename === void 0 ? void 0 : filename.endsWith(".sass"),
        importer: function (url /*, prev, done */) {
            // url is the path in import as is, which LibSass encountered.
            // prev is the previously resolved path.
            // done is an optional callback, either consume it or return value synchronously.
            // this.options contains this options hash, this.callback contains the node-style callback
            const urlPath = path_1.default.parse(url);
            const importerOptions = this.options;
            const incPaths = importerOptions.includePaths.slice(0).split(":");
            if (urlPath.dir.length > 0) {
                incPaths.unshift(path_1.default.resolve(filename ? path_1.default.dirname(filename) : process.cwd(), urlPath.dir)); // add the file's dir to the search array
            }
            const f = findVariant(urlPath.name, exts, incPaths);
            if (f) {
                return { file: f };
            }
        },
        file: filename,
        data: data,
    };
};
const parseCss = (options) => {
    const string = sass_1.default.renderSync(resolveSassOptions(options)).css.toString();
    const stylesheet = css_1.default.parse(string).stylesheet;
    if (!stylesheet) {
        throw new Error("[react-native-css-modules] Couldn't parse CSS");
    }
    return { css: string, stylesheet };
};
exports.parseCss = parseCss;
