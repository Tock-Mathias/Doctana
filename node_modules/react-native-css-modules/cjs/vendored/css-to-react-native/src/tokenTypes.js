"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LINE = exports.COLOR = exports.STRING = exports.IDENT = exports.PERCENT = exports.ANGLE = exports.UNSUPPORTED_LENGTH_UNIT = exports.LENGTH = exports.NUMBER = exports.AUTO = exports.NONE = exports.WORD = exports.COMMA = exports.SLASH = exports.SPACE = exports.regExpToken = void 0;
const postcss_value_parser_1 = require("postcss-value-parser");
const css_color_keywords_1 = __importDefault(require("css-color-keywords"));
const matchString = node => {
    if (node.type !== 'string')
        return null;
    return node.value
        .replace(/\\([0-9a-f]{1,6})(?:\s|$)/gi, (match, charCode) => String.fromCharCode(parseInt(charCode, 16)))
        .replace(/\\/g, '');
};
const hexColorRe = /^(#(?:[0-9a-f]{3,4}){1,2})$/i;
const cssFunctionNameRe = /^(rgba?|hsla?|hwb|lab|lch|gray|color)$/;
const matchColor = node => {
    if (node.type === 'word' &&
        (hexColorRe.test(node.value) ||
            node.value in css_color_keywords_1.default ||
            node.value === 'transparent')) {
        return node.value;
    }
    else if (node.type === 'function' && cssFunctionNameRe.test(node.value)) {
        return (0, postcss_value_parser_1.stringify)(node);
    }
    return null;
};
const noneRe = /^(none)$/i;
const autoRe = /^(auto)$/i;
const identRe = /(^-?[_a-z][_a-z0-9-]*$)/i;
// Note if these are wrong, you'll need to change index.js too
const numberRe = /^([+-]?(?:\d*\.)?\d+(?:e[+-]?\d+)?)$/i;
// Note lengthRe is sneaky: you can omit units for 0
const lengthRe = /^(0$|(?:[+-]?(?:\d*\.)?\d+(?:e[+-]?\d+)?)(?=px$))/i;
const unsupportedUnitRe = /^([+-]?(?:\d*\.)?\d+(?:e[+-]?\d+)?(ch|em|ex|rem|vh|vw|vmin|vmax|cm|mm|in|pc|pt))$/i;
const angleRe = /^([+-]?(?:\d*\.)?\d+(?:e[+-]?\d+)?(?:deg|rad))$/i;
const percentRe = /^([+-]?(?:\d*\.)?\d+(?:e[+-]?\d+)?%)$/i;
const noopToken = predicate => node => (predicate(node) ? '<token>' : null);
const valueForTypeToken = type => node => node.type === type ? node.value : null;
const regExpToken = (regExp, transform = String) => node => {
    if (node.type !== 'word')
        return null;
    const match = node.value.match(regExp);
    if (match === null)
        return null;
    const value = transform(match[1]);
    return value;
};
exports.regExpToken = regExpToken;
exports.SPACE = noopToken(node => node.type === 'space');
exports.SLASH = noopToken(node => node.type === 'div' && node.value === '/');
exports.COMMA = noopToken(node => node.type === 'div' && node.value === ',');
exports.WORD = valueForTypeToken('word');
exports.NONE = (0, exports.regExpToken)(noneRe);
exports.AUTO = (0, exports.regExpToken)(autoRe);
exports.NUMBER = (0, exports.regExpToken)(numberRe, Number);
exports.LENGTH = (0, exports.regExpToken)(lengthRe, Number);
exports.UNSUPPORTED_LENGTH_UNIT = (0, exports.regExpToken)(unsupportedUnitRe);
exports.ANGLE = (0, exports.regExpToken)(angleRe, angle => angle.toLowerCase());
exports.PERCENT = (0, exports.regExpToken)(percentRe);
exports.IDENT = (0, exports.regExpToken)(identRe);
exports.STRING = matchString;
exports.COLOR = matchColor;
exports.LINE = (0, exports.regExpToken)(/^(none|underline|line-through)$/i);
