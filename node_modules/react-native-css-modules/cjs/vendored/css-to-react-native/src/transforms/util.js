"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseShadow = exports.parseShadowOffset = exports.directionFactory = void 0;
const tokenTypes_1 = require("../tokenTypes");
const directionFactory = ({ types = [tokenTypes_1.LENGTH, tokenTypes_1.UNSUPPORTED_LENGTH_UNIT, tokenTypes_1.PERCENT], directions = ['Top', 'Right', 'Bottom', 'Left'], prefix = '', suffix = '', }) => tokenStream => {
    const values = [];
    // borderWidth doesn't currently allow a percent value, but may do in the future
    values.push(tokenStream.expect(...types));
    while (values.length < 4 && tokenStream.hasTokens()) {
        tokenStream.expect(tokenTypes_1.SPACE);
        values.push(tokenStream.expect(...types));
    }
    tokenStream.expectEmpty();
    const [top, right = top, bottom = top, left = right] = values;
    const keyFor = n => `${prefix}${directions[n]}${suffix}`;
    return {
        [keyFor(0)]: top,
        [keyFor(1)]: right,
        [keyFor(2)]: bottom,
        [keyFor(3)]: left,
    };
};
exports.directionFactory = directionFactory;
const parseShadowOffset = tokenStream => {
    const width = tokenStream.expect(tokenTypes_1.LENGTH);
    const height = tokenStream.matches(tokenTypes_1.SPACE) ? tokenStream.expect(tokenTypes_1.LENGTH) : width;
    tokenStream.expectEmpty();
    return { width, height };
};
exports.parseShadowOffset = parseShadowOffset;
const parseShadow = tokenStream => {
    let offsetX;
    let offsetY;
    let radius;
    let color;
    if (tokenStream.matches(tokenTypes_1.NONE)) {
        tokenStream.expectEmpty();
        return {
            offset: { width: 0, height: 0 },
            radius: 0,
            color: 'black',
        };
    }
    let didParseFirst = false;
    while (tokenStream.hasTokens()) {
        if (didParseFirst)
            tokenStream.expect(tokenTypes_1.SPACE);
        if (offsetX === undefined &&
            tokenStream.matches(tokenTypes_1.LENGTH, tokenTypes_1.UNSUPPORTED_LENGTH_UNIT)) {
            offsetX = tokenStream.lastValue;
            tokenStream.expect(tokenTypes_1.SPACE);
            offsetY = tokenStream.expect(tokenTypes_1.LENGTH, tokenTypes_1.UNSUPPORTED_LENGTH_UNIT);
            tokenStream.saveRewindPoint();
            if (tokenStream.matches(tokenTypes_1.SPACE) &&
                tokenStream.matches(tokenTypes_1.LENGTH, tokenTypes_1.UNSUPPORTED_LENGTH_UNIT)) {
                radius = tokenStream.lastValue;
            }
            else {
                tokenStream.rewind();
            }
        }
        else if (color === undefined && tokenStream.matches(tokenTypes_1.COLOR)) {
            color = tokenStream.lastValue;
        }
        else {
            tokenStream.throw();
        }
        didParseFirst = true;
    }
    if (offsetX === undefined)
        tokenStream.throw();
    return {
        offset: { width: offsetX, height: offsetY },
        radius: radius !== undefined ? radius : 0,
        color: color !== undefined ? color : 'black',
    };
};
exports.parseShadow = parseShadow;
